GET Method

GET method is used to fetch data from the FastAPI server.
It is not used to modify data.
Mainly used to retrieve data.

Use:

@app.get("/")
def function():
    return

Returning Mock Data (List of Dict) to Frontend

Manually created a list of dictionaries in Python, and now we want to return it to the frontend using APIs (mockdata.py).

Use:

from mockdata import products


Here, mockdata is a Python file, and inside it we stored products, which is a list of dictionaries.

@app.get("/products")
def products_list():
    return products

Dynamic Path Parameter

If we pass an id or count, it will return that particular key-value pair.
Basically, it returns specific information.

ðŸ‘‰ This is called a Path Parameter
We send parameters from the URL to the backend, then fetch data according to it.

@app.get("/products/{count}")
def product_detail(count: int):
    for i in products:
        if i["count"] == count:
            return i
    return {"error": "Product not found"}


Here we collect the count variable from the URL and pass it through an if condition.

If that particular count is present in the key-value pair, then it will return that data to the webpage.

Query Parameters

Example URL:

localhost:8000/greeting?name=pruthvi

@app.get("/greet")
def greet(name: str, age: int):
    return {"message": f"hello, {name}! you are {age} years old."}


We can also pass multiple parameters using:

?name=pruthvi&age=10


So multiple values can be passed through the URL easily.

Path Param vs Query Param

When you have a fixed number of parameters, use path parameters like:

greet/{variable1}/{variable2}


Here we must pass both variables strictly.

But when it comes to query parameters, we can pass any number of parameters without any problem:

def greet(name: str, age: int):


This is okay for 2â€“3 variables, but when the number of variables increases, a new concept comes in.

Request Object

When there are many query parameters, we use Request.

from fastapi import Request

http://127.0.0.1:8000/add?a=3&b=5
foramt above for passing the varibalbe 

@app.get("/greet")
def greet(req: Request):
    return {
        "message": f"hello, {req.query_params['name']}! you are {req.query_params['age']} years old."
    }


We create the req object using Request,
then access the query parameters using their names.

HTTP Methods in FastAPI

GET, POST, PUT, DELETE

1. GET

Client requests data from the server, and the server responds.

Flow:

client  ==>  server
client  <==  server


Used to get data from server.

2. POST

Client sends data to the server.
Server stores the data in the database.

Server also sends a confirmation response back to the client.

3. PUT

Used to update existing data in server/database.

Client sends:

(data, data_id)


So the server knows which data to update.

4. DELETE

Client requests to delete data by sending the data_id.

(Delete, data_id)

CRUD

These four methods together are called CRUD:

Create â†’ POST

Read â†’ GET

Update â†’ PUT

Delete â†’ DELETE

Almost all applications work on these CRUD operations.




## The Database setup using the postgres sql and sqlalcamy of python for this 
we have first create evn file of database connection string 

..



so to perform the curd opperation in fastapi we have setup an connection between the 
task.controller file => router file=> main file

defien the fucntion into the controller file 
def create_task(body:TaskSchema,db:Session):
    data = body.model_dump()
    newtask = TaskModel(title=data['title'],description=data['description'],is_completed=data['is_completed'])
    db.add(newtask)
    db.commit()
    db.refresh(newtask)
    return {"status":"success","data":newtask}

def get_tasks(db:Session):
    tasks = db.query(TaskModel).all()
    return {"status":"success","data":tasks}

def get_task_by_id(task_id:int,db:Session):
    task = db.query(TaskModel).get(task_id)
    return {"status":"success","data":task}


def update_task(task_id:int, body:TaskSchema, db:Session):
    one_task = db.query(TaskModel).get(task_id)
    if not one_task:
        return {"status":"failed","message":"Task not found"}
    
    one_task.title = body.title
    one_task.description = body.description 
    
    one_task.is_completed = body.is_completed   
    db.add(one_task)
    db.commit()
    db.refresh(one_task)
    return {"status":"success","data":one_task}

    like above for tasks such as update add get one 

    and then route it correclty \




    @task_router.post("/create")
def create_task(body: TaskSchema,db = Depends(get_db)):
    return controller.create_task(body,db) 


@task_router.get("/all")
def get_tasks(db = Depends(get_db)):
    return controller.get_tasks(db)



@task_router.get("/one/{task_id}")
def get_task_by_id(task_id:int,db = Depends(get_db)):
    one_task = db.query(controller.TaskModel).get(task_id)    
    if not one_task:
            raise HTTPException(status_code=400,detail="Task ID is required")
    return {"status":"success","data":one_task}


@task_router.put("/update/{task_id}")
def update_task(task_id:int, body:TaskSchema, db = Depends(get_db)):
    return controller.update_task(task_id,body,db)

like this 


http status code 
for get request it 200
for put update its 201
for del its 204

here add info about the response model is used in the code 
class TaskResponseSchema(BaseModel):
    id: int
    title: str
    description: str
    is_completed: bool


how this will befnints our codde privicy 
@task_router.post("/create",response_model=TaskResponseSchema,status_code=status.HTTP_201_CREATED)
def create_task(body: TaskSchema,db = Depends(get_db)):
    return controller.create_task(body,db) 
